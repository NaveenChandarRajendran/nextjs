What is a Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".

............................................................................................
				Rendering Types
............................................................................................

What is Rendering?
   Render means preparation,HTML Page prepartion...

Rendering Types:
1.CSR- Client side Rendering.
   HTML Pages are prepared at client side - SPA Applications
2.SSR  -Server Side rendering
   HTML Pages are prepared at server side - Dynamic Content Generation applications.

Based on these rendering type, we can classify other rendering

1.Universal rendering /Hybrid Rendering
  Server + Client side , coimbing both rendering

2.Full SSR and Partial SSR
   Partial SSR is nothing but only "index.html" is compiled at server , rest of the application is rendered at client side.
   Full SSR is nothing but "index.html" and other pages are compiled at server....

.............................................................................................
			When Rendering can happen
		     (when html pages are parepared)
.............................................................................................

1.Request time
2.Build time

1.Request time :
 When user types url 

  http://www.example.com/product--------------->Server Receives Request----Prepares Page--send   that page to client.

2.Build time
    Build is nothing but, preparing app for production.. before hosting we have to prepare the     app
  During build phase, we can prepare html pages/render html pages 

			SSG -  Static Site Generations

Building web sites/apps during build phase is called SSG.

Why SSG?
  Super fast page access

Based On SSG , There is specfication is available "JAM Stack"

...........................................................................................
			Drawback of SSG(JAMStack App)
..........................................................................................
If page has data, which is keep on changing, preparing a page "ahead of time", that causes problem. that means we cant generate page on demand...

Data changes rapidly , we need to enable request time page prepartion.

...........................................................................................
			ISR - Incremental Static Rendenering
..........................................................................................

SSG - Build time or ahead of time
SSR - Request time

ISR = SSG + SSR - Build time + request time 

.............................................................................................

What is Nextjs?

  Next js is a framework that helps to build web apps of all types

 you can build Full SSR apps..
 you can build SSR With Request time
 you can build SSG with Build time -  JAMStacks
 you can build SSR with CSR  - Server + SPA - Hybrid rendering
 you can build rest apis also - Web services

Using Next you can build 
 Pure server side apps with database access, other external api access.....

..............................................................................................
		               Next js UI layer
.............................................................................................

Next js uses "react core features" to build UI layer...

React core features:
1.React compoent driven
2.React uses data mutation techniques like props and state
3.React uses event listeners for interactions
4.React hooks

Nextjs tech stack:

1.React as ui layer
2.Next does not recommend to use "redux"
3.Next uses api layer- rest api development
4.Next can talk to any database via orm frameworks...

..............................................................................................
			Next js Architecture:
.............................................................................................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming langugage, used to build Nextjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 17x faster than Babel, it is embeded inside next js
...........................................................................................

....................................................................................
		NEXT JS Getting Started
....................................................................................

To install - npx create-next-app@latest

How to declare compoents?

 1.every component must be "functional component" - No Class Component.
 2.every component must be exported using "export default" only.
 3.Every Next application must have "root layout" src/app/layout.js
 4.Every Next application must have  "home/landing page" src/app/page.js


....................................................................................
		Patterns for client and server components

1.Server component uses client component...

2.Client component uses another server component

3.Client component uses another client component

1.Server Component uses client component:
.........................................

server:

src/app/reviews/page.js
import Like from "./like";

export default function ReviewPage(){
    return <>
        <h1>Review Page</h1>
        <Like/>
    </>
}
client component
src/app/reviews/like.jsx
'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if server uses client, the component must be marked with "use client" directive..

 ...................................................................................

2.Client component uses another server component.

  if client uses another server component, Server Component automatically becomes client component.
 when we use this pattern, we loose server rendering...


}

server:
src/app/reviews/Dislike.jsx
export default function DislikeServer() {
      return <div>
       <h1>Dislike Server</h1>
    </div>
}

Client:
src/app/reviews/reviewClient.jsx
'use client'
import { useState } from "react"
import DislikeServer from "./Dislike"

export default function MyReview() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
        {/* Use server component */}
        <DislikeServer/>
    </div>
}
In the code, DislikeServer component runs in the client only....

What if client uses server component but at the same time, i dont want to loose server rendering feature?

Solution:

 Pass Server component as prop to Child Component..

<Client>
    <Server/>
</Client>

src/app/client/myserver.jsx
export default function MyServer(){
    return <div>
        <h1>Server Component</h1>
    </div>
}
src/app/client/myclient.jsx
'use client'

// import MyServer from "./myserver"

export default function MyClient(props){
    return <div>
        <h1>Client component</h1>
        {/* <MyServer></MyServer> */}
        {props.children}
    </div>
}

src/app/client/page.js
import MyClient from "./myclient";
import MyServer from "./myserver";

export default function ClientPage() {
    return <>
        <h1>Client Page</h1>
        <MyClient>
            {/* sending server as prop  */}
            <MyServer/>
        </MyClient>
    </>
}
....................................................................................

3.Client Uses another client Component...

Client uses another client.

src/app/myreviews/page.js
import MyReview from "./MyReview";

export default function Likes(){
    return <div>
        MyReview Page
        <MyReview></MyReview>
    </div>
}

Client:

src/app/myreviews/MyReview.jsx

'use client'

import Like from "./like"

export default function MyReview() {
        return <>
        <Like></Like>
    </>
}
src/app/myreviews/like.jsx
// 'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if client component uses another client component, that another client component no need to use "use client" directive.
This would be very use full when we use third party ui components into next js...
primiarly used for migration...

....................................................................................
			Advanced Routing - Linking and Navigation
......................................................................................

		...............Linking and Navigation.......


There are four ways to navigate between routes in Next.js

1.Using <Link> Component
2.Using useRouter Hook
3.redirect function
4.Using native History api

Reddirection/navigation can happen in two places

1.Server side redirection/navigation
   Redirection is controlled by server
2.Client side redirection/navigation
   Redirection is controlled by browser

.....................................................................................
				useRouter Hook
.....................................................................................

userRouter hook allows you programmatically change route from client components.

src/app/components/DashboardNavigator.jsx

'use client'
import { useRouter } from "next/navigation"

export function DashBoardNavigator() {
    const router = useRouter()
    return <>
        <button onClick={() => {
            router.push('/dashboard')
        }}>Dashboard</button>
    </>
}

src/app/page.js
import { DashBoardNavigator } from "./components/DashboardNavigator";


export default function HomePage() {
  return <div>
    <h1>Home Page</h1>
    <DashBoardNavigator/>
  </div>
}

src/app/components/links.jsx
'use client'
import { usePathname } from "next/navigation";
import Link from "next/link";
import './link.css'

export function Links() {
    const pathname = usePathname()
    return <nav>
        <ul>
           <li>
                <Link className={`link ${pathname === '/dashboard' ? 'active' : ''}`} href={{ pathname: '/dashboard' }}>Dashboard</Link>
            </li>
        </ul>
    </nav >
}

....................................................................................
			Advanced Routing-Dynamic routes
			 "Catch-All Segment Routing"
...................................................................................

Dynamic segments can be extended to catch all subsequent by adding [...slug]

Without CatchAll:
................

/shop/a 
/shop/b
/shop/c

shop
  |
  [a]
    |
    page.js
  |
  [b]
   |
    page.js
  [c]
   |
    page.js
 page.js

what if dynamic routes are not predefined in advance.

With Catch All:
................

 shop
  |
  page.js
  |
  [...slug]
    |
    page.js

/shop/tops
/shop/tops/tshirt
/shop/dress/men/shirt

How to capture parameter?
 {
   slug:['tops','tshirt','men','shirt']
 }


src/app/shop/page.js
export default function ShopPage() {
    return <>
        <h1>Shop Page</h1>
    </>
}

src/app/shop/[...slug]/page.js
export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page</h1>
        <h2>{JSON.stringify(params)}</h2>
    </>
}

.....................................................................................
			 Advanced Routing-Dynamic Routes
		       "Optional Catch-All Segment Routing"
		
In the catch-All segement routing, the root folder has page.js, without that page.js what will happen>

src/app/shop/[...slug]/page.js

http://localhost:3000/shop
  ->It will throw page not found.

There would be use case , i dont want page.js inside /shop.

Thats where Optional CatchAll segment Routing comes picture..

src/app/shop/[[...slug]]
             |
     page.js

Eg:

src/app/shop/[[...slug]]/page.js
export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page</h1>
        <h2>{JSON.stringify(params)}</h2>
    </>
}

Conclusion in dynamic routing:

 src/app/user/[id]- static dynamic routing
 src/app/shop/tops - dynamic catch all routing
 src/shop/
       page.js
 src/shop/[...slug]/page.js
 src/app/shop/[[...slug]]/page.js -dynamic optional catch all routing

 .....................................................................................
				 Data Fetching
.....................................................................................

Types of Data Fetching:

1.Server side data fetching
2.Client side Data fetching

.....................................................................................
		  Server side data fetching using "fetch" api
.....................................................................................

etching data on the server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.

React extends fetch to automatically memoize fetch requests while rendering a React component tree.

There are four places You can use fetch:
1.Server components
2.Client Components
3.Route Handlers,REST API
4.Server Actions

....................................................................................
			   Fetching data from external API using "fetch" api
....................................................................................

src/app/todos/layout.js
//data fetching in server component using fetch 
export async function fetchTodos() {
    console.log('layout')

    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}
export default async function TodosLayout(props) {
    const todos = await fetchTodos()

    return <div>
        <h1>Total Todos {todos.length}</h1>
        {props.children}
    </div>
}

src/app/todos/page.js


//data fetching in server component using fetch 
export async function fetchTodos() {
    console.log('page')
    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <>
        <h1>Todos Page</h1>
        <ul>
            {todos.map(todo => <li key={todo.id}>{todo.title}</li>)}
        </ul>
    </>
}..................................................................................
			.....................................................................................
		  Server side data fetching using  "third party" api-axios
.....................................................................................

You can use any third party ajax api to call apis from next application but which is not recommended, because other apis will not have features such as caching,revalidation,request memoziation, we have to write extra code.
.....................................................................................

.....................................................................................
	     Data fetching in Client components-Using fetch api
....................................................................................

src/app/components/FetchPosts.jsx
'use client'

import { useEffect, useState } from "react"

export default function FetchPost() {
    const [posts, setPosts] = useState([])
    useEffect(() => {
        async function fetchPostsDetails() {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const response = await fetch(url)
            const posts = await response.json()
            setPosts((myposts) => {
                return posts.concat(myposts)
            })
        }
        fetchPostsDetails()
        return () => {
            return null
        }
    }, [])
    return <>
        <h1>Posts</h1>
        <ul>
            {posts.map(post => {
                return <li>
                    <span>{post.title}</span>
                </li>
            })}
        </ul>
    </>
}
src/app/posts/page.js

import FetchPost from "@/app/components/FetchPosts";

export default function PostPage(){
    return <div>
        <h1>Post Page Fetching Data from the Client Side</h1>
        <FetchPost/>
    </div>
}

Using fetch api in client components is not recommended, the reason which has no any caching feature is enabled, so fetch must be used only in server side.\\

.....................................................................................
How to fetch data in client comonpents?

		Data Fetching in Client Components using SWR API
....................................................................................

what is SWR?
 The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861(opens in a new tab). SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.

 Why SWR
1.Client side caching by default
2.Cache revalidation by default
3.You dont need to write hooks like useEffect,useState,
4.You get data,error,loading flags

....................................................................................
		Data Fetching using Route Handler
	      (REST API Development and Integration)
....................................................................................

Next.js Provides a layer called "API" Layer in order to build REST API.

API layer can be used to write REST API which may talk to databases or external rest api or Graphql api or Microservices..

Route handler:
 Route handlers are used to CREATE API In next.js

File Name convention:
route.js

src/app/todos/
  page.js
  layout.js
  route.js - it is not recommended to write like this...


src/app/api/
  todos
     route.js
  [id]
     route.js

url pattern:
  /api/todos
  /api/customers
  /api/products

Inside Route Handler How to write code?

export async function HTTPVerb(request){ 

}
=>Always route function must have "export" only
=>Function must have async keyword
=>Function args must have request object

Supported Verbs:
GET
POST
PUT
PATCH
DELETE
HEAD
OPTIONS


APIS:
 NextRequest Object used to handle client request
 NextResponse Object used to send response to the client.

...................................................................................
			How to read Payload- data
....................................................................................

Payload For 
1.Insert/save
2.Update

//POST
src/app/api/message/route.js

import { NextResponse } from "next/server";

export async function GET(request) {
    //send response
    return NextResponse.json({ message: 'Hello api' })
}
export async function POST(request) {
    //read body
    const payload = await request.json()
    console.log(payload)
    return NextResponse.json({ message: 'saved' })
}

Testing:

POST http://localhost:3000/api/greeter

{
    "message": "Hello",
    "by": "Subramanian",
    "whom": "Murugan"
}